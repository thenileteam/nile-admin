import database from "../utils/database";
import getTimeBuckets from "../utils/get-time-buckets";

class DashboardService {
    getThisWeekOrdersStats = async (): Promise<any> => {
        const { year, month, week } = getTimeBuckets(new Date()); 
        
        const stats = await database.dashboardStat.findMany({
            where: { 
                // This structure is correct for filtering by individual fields
                year: year, 
                month: month, 
                week: week, 
                metricType: "orders" 
            },
        });
        
        return stats;
    };
    getMonthOrdersTrends = async (): Promise<any> => {
        const { year } = getTimeBuckets(new Date());
        const stats = await database.dashboardStat.groupBy({
            by: ["month"],
            where: { year: year, metricType: "orders" },
            _sum: { value: true },
        });
        return stats;
    };

    getFailedOrdersPieChartByReason = async (): Promise<any> => {
        const { year } = getTimeBuckets(new Date());
      
        // Get top 5 reasons
        const topStats = await database.failedOrderReason.groupBy({
          by: ["reason"],
          where: { year },
          _sum: { value: true },
          orderBy: { _sum: { value: "desc" } },
          take: 5,
        });
      
        // Get total across all reasons
        const total = await database.failedOrderReason.aggregate({
          where: { year },
          _sum: { value: true },
        });

        const topSum = topStats.reduce((acc: number, s: { _sum: { value: number | null } }) => acc + (s._sum.value || 0), 0);
        const totalSum: number = total._sum.value || 0;
        const others: number = totalSum - topSum;

        // Format response
        const result = topStats.map((s: { reason: string; _sum: { value: number | null } }) => ({
          reason: s.reason,
          value: s._sum.value || 0,
        }));
      
        if (others > 0) {
          result.push({ reason: "Others", value: others });
        }
      
        return result;
      };
      

      updateDashboardStat = async (metricType: "orders" | "settlements" | "failed_orders", createdAt: Date, value: number): Promise<void> => {
        const { year, month, week } = getTimeBuckets(createdAt);
        
        await database.dashboardStat.update({
            where: {
                // FIX: Use the specific composite key name generated by Prisma
                metricType_year_month_week: {
                    metricType: metricType,
                    year: year,
                    month: month,
                    week: week,
                },
            },
            data: { value: value },
        });
    };

    getThisWeekFailedOrdersReasons = async (): Promise<any> => {
        // This function is assumed to correctly calculate the current year, month, and week
        const { year, month, week } = getTimeBuckets(new Date()); 
        
        const failedOrderReasons = await database.failedOrderReason.findMany({
            where: { 
                // Corrected filtering: use the individual field names
                reason: "failed_orders", 
                year: year, 
                month: month, 
                week: week 
            },
        });
        
        return failedOrderReasons;
    };

    updateFailedOrderReason = async (reason: string, createdAt: Date, value: number): Promise<void> => {
        const { year, month, week } = getTimeBuckets(createdAt);
        await database.failedOrderReason.update({
            where: { reason, year, month, week },
            data: { value },
        });
    };
}

export const dashboardService = new DashboardService();